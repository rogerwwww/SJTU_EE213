/* Main.c file generated by New Project wizard
 *
 * Created:   周三 4月 12 2017
 * Processor: 8086
 * Compiler:  Digital Mars C
 *
 * Before starting simulation set Internal Memory Size 
 * in the 8086 model properties to 0x10000
 */
#include "header.h"


static unsigned char SEGTAB[16]={
   3FH,	// 7-Segment Tube, 共阴极类型的7段数码管示意图
   06H,
   5BH,	//            a a a
   4FH,	//         f         b
   66H,	//         f         b
   6DH, //         f         b
   7DH, //            g g g 
   07H, //         e         c
   7FH,	//         e         c
   6FH,	//         e         c
   77H,	//            d d d     h h h
   7CH,	// ----------------------------------
   39H,	//       b7 b6 b5 b4 b3 b2 b1 b0
   5EH,	//       DP  g  f  e  d  c  b  a
   79H,	//
   71H
};
static unsigned char studentNo = 5Dh;
unsigned int displayPointer = 0;
unsigned int toDisp[4] = {0, 2, 8, 5};

void main(void)
{
   //service initiate
   INT_INIT();
   INIT8255();
   INIT8253(10000, 0, 3);
   INIT8253(100, 1, 3);
   INIT8253(35, 2, 0);
   __asm{STI}
   //endless loop
   while (1)
   {
      for(int i = 0; i < 4; i++)
	  {
		  DISPLAY8255(i, toDisp[i]);
		  DELAY(40);
	  }
      AccessPC();
	  FeedDog(35);
   }
}
 
 
void INIT8255(void)
{
	io_write_byte(L8253CS, 0x81);
}

void INIT8253(unsigned int time, unsigned int counter, unsigned int mode)
{
	unsigned int target_addr;
	unsigned char control_word;
	switch(counter)
	{
		case 0:
		target_addr = L8253T0;
		control_word = 0x30;
		break;
		case 1:
		target_addr = L8253T1;
		control_word = 0x70;
		break;
		case 2:
		target_addr = L8253T2;
		control_word = 0xB0;
		break;
		default: return;
	}
	mode *= 2;
	control_word += mode;
	io_write_word(L8253CS, control_word);
	io_write_word(target_addr, time);
	time >>= 8;
	io_write_word(target_addr, time);
}

void FeedDog(unsigned int period)
{
	//看门狗喂狗程序，周期(period*2)ms
	io_write_word(L8253T2, period);
	period >>= 8;
	io_write_word(L8253T2, period);
}

void AccessPC(void)
{
	unsigned char buffer;
	buffer = io_read(L8255PC);
	if(buffer & 1)
		buffer &= 0xBF;
	else
		buffer |= 0x40;
	io_write_byte(L8255PC, buffer);
}


void DISPLAY8255(unsigned int segment, unsigned int displayNum)
{
	unsigned char toPA;
	switch(segment)
	{
		case 0: toPA = 0xFE; break;
		case 1: toPA = 0xFD; break;
		case 2: toPA = 0xFB; break;
		case 3: toPA = 0xF7; break;
		default: return;
	}
	
	io_write_byte(L8255PA, toPA);
	io_write_byte(L8255PB, SEGTAB[displayNum]);	
}

void DELAY(unsigned int delayCycle)
{
   __asm
   {
    	PUSH CX
    	MOV CX, delayCycle
D1: 	LOOP D1
    	POP CX
   }
}

void INT_INIT(void)
{
   __asm
   {
		MOV AX, 0
		MOV ES, AX				// 准备操作中断向量表
		
								//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		MOV AX, OFFSET MYIRQ	//! Incorrect if using LEA! dont know why
								//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		
		MOV BL, studentNo		//calculate interrupt offset
		MOV BH, 0
		SHL BX, 1
		SHL BX, 1
		MOV ES:[BX], AX			//write interrupt service address into memory, IP first
		MOV AX, CS
		INC BX
		INC BX
		MOV ES:[BX], AX			//then CS
   }
}

void _interrupt _far MYIRQ(void)
{
	unsigned int tmp = toDisp[0];
	unsigned char readin;
	toDisp[0] = toDisp[1];
	toDisp[1] = toDisp[2];
	toDisp[2] = toDisp[3];
	toDisp[3] = tmp;
	
	readin = io_read(L8255PC);
	readin ^= 0x80;
	io_write_byte(L8255PC, readin);
	displayPointer++;
}

void io_write_word(unsigned int addr, unsigned int outword)
{
	__asm
	{
		MOV DX, addr
		MOV AX, outword
		OUT DX, AX
	}
}

void io_write_byte(unsigned int addr, unsigned char outbyte)
{
	__asm
	{
		MOV DX, addr
		MOV AL, outbyte
		OUT DX, AL
	}
}

unsigned int io_read(unsigned int addr)
{
	unsigned int inword;
	__asm
	{
		MOV DX, addr
		IN AX, DX
		MOV inword, AX
	}
	return inword;
}